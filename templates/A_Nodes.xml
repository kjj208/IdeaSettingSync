<templateSet group="A~Nodes">
  <template name="~~~~" value="~~~" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="枚举类" value="/**&#10; * 使用enum关键字定义枚举类&#10; * 说明：定义的枚举类默认继承于java.lang.Enum类&#10; *&#10; * @author shkstart&#10; * @create 2019 上午 10:35&#10; */&#10;public class SeasonTest1 {&#10;    public static void main(String[] args) {&#10;        Season1 summer = Season1.SUMMER;&#10;        //toString():返回枚举类对象的名称&#10;        System.out.println(summer.toString());//父类定义的toString();只会输出枚举的名称&#10;&#10;//        System.out.println(Season1.class.getSuperclass());&#10;        System.out.println(&quot;****************&quot;);&#10;        //values():返回所有的枚举类对象构成的数组&#10;        Season1[] values = Season1.values();&#10;        for (int i = 0; i &lt; values.length; i++) {&#10;            System.out.println(values[i]);&#10;            values[i].show();&#10;        }&#10;        System.out.println(&quot;****************&quot;);&#10;        Thread.State[] values1 = Thread.State.values();&#10;        for (int i = 0; i &lt; values1.length; i++) {&#10;            System.out.println(values1[i]);&#10;        }&#10;        System.out.println(&quot;****************&quot;);&#10;        //valueOf(String objName):返回枚举类中对象名是objName的对象。&#10;        Season1 winter = Season1.valueOf(&quot;WINTER&quot;);&#10;        //如果没有objName的枚举类对象，则抛异常：IllegalArgumentException&#10;//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);&#10;        System.out.println(winter);&#10;&#10;        System.out.println(winter.getSeasonName());&#10;        System.out.println(winter.getSeasonDesc());&#10;//        winter.show();&#10;    }&#10;}&#10;&#10;interface Info {&#10;    void show();&#10;}&#10;&#10;//使用enum关键字枚举类&#10;enum Season1 implements Info {&#10;    //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束&#10;    SPRING(&quot;春天&quot;, &quot;春暖花开&quot;) {&#10;        @Override&#10;        public void show() {&#10;            System.out.println(&quot;春天在哪里？&quot;);&#10;        }&#10;    },&#10;    SUMMER(&quot;夏天&quot;, &quot;夏日炎炎&quot;) {&#10;        @Override&#10;        public void show() {&#10;            System.out.println(&quot;宁夏&quot;);&#10;        }&#10;    },&#10;    AUTUMN(&quot;秋天&quot;, &quot;秋高气爽&quot;) {&#10;        @Override&#10;        public void show() {&#10;            System.out.println(&quot;秋天不回来&quot;);&#10;        }&#10;    },&#10;    WINTER(&quot;冬天&quot;, &quot;冰天雪地&quot;) {&#10;        @Override&#10;        public void show() {&#10;            System.out.println(&quot;大约在冬季&quot;);&#10;        }&#10;    };&#10;&#10;    //2.声明Season对象的属性:private final修饰&#10;    private final String seasonName;&#10;    private final String seasonDesc;&#10;&#10;    //2.私有化类的构造器,并给对象属性赋值&#10;&#10;    private Season1(String seasonName, String seasonDesc) {&#10;        this.seasonName = seasonName;&#10;        this.seasonDesc = seasonDesc;&#10;    }&#10;&#10;    //4.其他诉求1：获取枚举类对象的属性&#10;    public String getSeasonName() {&#10;        return seasonName;&#10;    }" description="" toReformat="false" toShortenFQNames="true" />
  <template name="注解类" value="/**&#10; * @author shkstart&#10; * @create 2019 上午 11:56&#10; */&#10;//如何自定义注解：参照@SuppressWarnings定义&#10;//元注解(修饰其他注解的注解)&#10;@Inherited //被它修饰的 Annotation 将具有继承性。&#10;//@Repeatable(MyAnnotations.class)//可重复注解&#10;@Retention(RetentionPolicy.RUNTIME)//生命周期//指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME&#10;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE})&#10;//用于指定被修饰的 Annotation 能用于修饰哪些程序元素&#10;//TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#10;//     类      变量     方法     形参        构造器         局部变量&#10;public @interface MyAnnotation {&#10;&#10;    //没有成员变量的表示是标识作用例如@Override&#10;    String value() default &quot;hello&quot;; //看着像方法其实是成员变量&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true" />
</templateSet>