<application>
  <component name="AppStorage">
    <histories>
      <item value="Constructs a new runtime exception with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to {@link initCause}. @param message the detail message. The detail message is saved for later retrieval by the {@link getMessage()} method." />
      <item value="A container object which may or may not contain a non-null value. If a value is present, {@code isPresent()} will return {@code true} and {@code get()} will return the value. &lt;p&gt;Additional methods that depend on the presence or absence of a contained value are provided, such as {@link orElse(java.lang.Object) orElse()} (return a default value if value not present) and {@link ifPresent(java.util.function.Consumer) ifPresent()} (execute a block of code if the value is present). &lt;p&gt;This is a &lt;a href=&quot;..langdoc-filesValueBased.html&quot;&gt;value-based&lt;a&gt; class; use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on instances of {@code Optional} may have unpredictable results and should be avoided. @since 1.8" />
      <item value="Internal" />
      <item value="Could not transfer artifact org.springframework.boot:spring-boot-dependencies:pom:2.3.7.RELEASE fromto alimaven (http:maven.aliyun.comnexuscontentgroupspublic): Transfer failed for http:maven.aliyun.comnexuscontentgroupspublicorgspringframeworkbootspring-boot-dependencies2.3.7.RELEASEspring-boot-dependencies-2.3.7.RELEASE.pom" />
      <item value="true if we are declaring a durable exchange (the exchange will survive a server restart)" />
      <item value="rue if we are declaring a durable exchange (the exchange will survive a server restart)" />
      <item value="the exchange type" />
      <item value="Actively declare a non-autodelete exchange with no extra arguments @see com.rabbitmq.client.AMQP.Exchange.Declare @see com.rabbitmq.client.AMQP.Exchange.DeclareOk @param exchange the name of the exchange @param type the exchange type @param durable true if we are declaring a durable exchange (the exchange will survive a server restart) @throws java.io.IOException if an error is encountered @return a declaration-confirm method to indicate the exchange was successfully declared" />
      <item value="Wait until all messages published since the last call have been either ack'd or nack'd by the broker. Note, when called on a non-Confirm channel, waitForConfirms throws an IllegalStateException. @return whether all the messages were ack'd (and none were nack'd) @throws java.lang.IllegalStateException" />
      <item value="true to acknowledge all messages up to and including the supplied delivery tag; false to acknowledge just the supplied delivery tag." />
      <item value="the tag from the received" />
      <item value="other properties for the message - routing headers etc" />
      <item value="the exchange to publish the message to" />
      <item value="Publishing to a non-existent exchange will result in a channel-level protocol exception, which closes the channel." />
      <item value="Publish a message." />
      <item value="Publish a message. Publishing to a non-existent exchange will result in a channel-level protocol exception, which closes the channel. Invocations of &lt;code&gt;ChannelbasicPublish&lt;code&gt; will eventually block if a &lt;a href=&quot;http:www.rabbitmq.comalarms.html&quot;&gt;resource-driven alarm&lt;a&gt; is in effect. @see com.rabbitmq.client.AMQP.Basic.Publish @see &lt;a href=&quot;http:www.rabbitmq.comalarms.html&quot;&gt;Resource-driven alarms&lt;a&gt; @param exchange the exchange to publish the message to @param routingKey the routing key @param props other properties for the message - routing headers etc @param body the message body @throws java.io.IOException if an error is encountered" />
      <item value="Invocation" />
      <item value="Isolation" />
      <item value="Propagation" />
      <item value="/* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */" />
      <item value="/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */" />
      <item value="initial Value" />
      <item value="Custom Constant" />
      <item value="tracker" />
      <item value="Handler Interceptor" />
      <item value="Content Negotiating View Resolver" />
      <item value="release" />
      <item value="acquire" />
      <item value="** * Releases a permit, returning it to the semaphore. * * &lt;p&gt;Releases a permit, increasing the number of available permits by * one. If any threads are trying to acquire a permit, then one is * selected and given the permit that was just released. That thread * is (re)enabled for thread scheduling purposes. * * &lt;p&gt;There is no requirement that a thread that releases a permit must * have acquired that permit by calling {@link #acquire}. * Correct usage of a semaphore is established by programming convention * in the application. */" />
      <item value="Barrier" />
      <item value="Semaphore" />
      <item value="usable bits of normal node hash" />
      <item value="Table initialization and resizing control. When negative, the * table is being initialized or resized: -1 for initialization, * else -(1 + the number of active resizing threads). Otherwise, * when table is null, holds the initial table size to use upon * creation, or 0 for default. After initialization, holds the * next element count value upon which to resize the table. */" />
      <item value="init Table" />
      <item value="Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead." />
      <item value="The next size value at which to resize (capacity * load factor)." />
      <item value="the table is in creation mode." />
      <item value="Adds the specified element as the tail (last element) of this list." />
      <item value="offer" />
      <item value="poll" />
      <item value="peek" />
      <item value="Returns the (non-null) Node at the specified element index." />
      <item value="@param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied." />
      <item value="Policy" />
      <item value="Rejected" />
      <item value="Synchronous Queue" />
      <item value="Count Down Latch" />
      <item value="for (int i = 0; i &lt; 6; i++) { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+&quot;\t离开教室&quot;); },String.valueOf(i)).start(); } System.out.println(&quot;关门&quot;);" />
      <item value="Invalid bound statement" />
      <item value="evict" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="285" />
        <entry key="ENGLISH" value="287" />
        <entry key="CROATIAN" value="1" />
        <entry key="ROMANIAN" value="4" />
        <entry key="SPANISH" value="2" />
        <entry key="ITALIAN" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1612257336586" />
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>