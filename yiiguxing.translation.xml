<application>
  <component name="AppStorage">
    <histories>
      <item value="available" />
      <item value="java.lang.IllegalStateException: Failed to check the status of the service com.ylzinfo.ehc.empi.service.db.IEmpiMmpConfigService. No provider available for the service com.ylzinfo.ehc.empi.service.db.IEmpiMmpConfigService from the url zookeeper:127.0.0.1:12181com.alibaba.dubbo.registry.RegistryService?application=ehc-empi-web&amp;default.timeout=1000000&amp;dubbo=2.5.3&amp;interface=com.ylzinfo.ehc.empi.service.db.IEmpiMmpConfigService&amp;methods=selectByPrimaryKey,insertSelective,updateByPrimaryKeySelective,updateByPrimaryKey,insert,deleteByPrimaryKey&amp;pid=10373&amp;revision=1.0&amp;side=consumer&amp;timestamp=1622445366882 to the consumer 192.168.34.2 use dubbo version 2.5.3" />
      <item value="No provider available for the service com.ylzinfo.ehc.empi.service.db" />
      <item value="nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.ylzinfo.ehc.empi.service.db.IEmpiMmpConfigService com.ylzinfo.ehc.empi.web.xm.UserTypePageController.empiMmpConfigService;" />
      <item value="nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.ylzinfo.empi.credit.web.QueryUserCreditStateService com.ylzinfo.ehc.empi.service.sdk.old.SdkCreditQueryService.queryUserCreditStateService;" />
      <item value="[ERROR] [DUBBO] Error creating bean with name 'com.ylzinfo.ehc.empi.service.sdk.ISdkCreditQueryService': Cannot resolve reference to bean 'sdkCreditQueryService' while setting bean property 'ref'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sdkCreditQueryService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.ylzinfo.empi.credit.web.QueryUserCreditStateService com.ylzinfo.ehc.empi.service.sdk.old.SdkCreditQueryService.queryUserCreditStateService; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'queryUserCreditStateService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.ylzinfo.empi.credit.engine.UserEngineService com.ylzinfo.empi.credit.web.QueryUserCreditStateService.userEngineService; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userEngineService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.ylzinfo.empi.credit.async.AsyncUserInfoService com.ylzinfo.empi.credit.engine.UserEngineService.asyncUserInfoService; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'asyncUserInfoService': Bean with name 'asyncUserInfoService' has been injected into other beans [creditEngineService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example., dubbo version: 2.5.3, current host: 192.168.34.2 org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'com.ylzinfo.ehc.empi.service.sdk.ISdkCreditQueryService': Cannot resolve reference to bean 'sdkCreditQueryService' while setting bean property 'ref'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sdkCreditQueryService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.ylzinfo.empi.credit.web.QueryUserCreditStateService com.ylzinfo.ehc.empi.service.sdk.old.SdkCreditQueryService.queryUserCreditStateService; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'queryUserCreditStateService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.ylzinfo.empi.credit.engine.UserEngineService com.ylzinfo.empi.credit.web.QueryUserCreditStateService.userEngineService; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userEngineService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.ylzinfo.empi.credit.async.AsyncUserInfoService com.ylzinfo.empi.credit.engine.UserEngineService.asyncUserInfoService; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'asyncUserInfoService': Bean with name 'asyncUserInfoService' has been injected into other beans [creditEngineService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example." />
      <item value="nested" />
      <item value="[ERROR] [DUBBO] Error creating bean with name 'com.ylzinfo.ehc.empi.service.sdk.ISdkCreditQueryService': Cannot resolve reference to bean 'sdkCreditQueryService' while setting bean property 'ref'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sdkCreditQueryService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.ylzinfo.empi.credit.web.QueryUserCreditStateService com.ylzinfo.ehc.empi.service.sdk.old.SdkCreditQueryService.queryUserCreditStateService; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'queryUserCreditStateService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.ylzinfo.empi.credit.engine.UserEngineService com.ylzinfo.empi.credit.web.QueryUserCreditStateService.userEngineService; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userEngineService': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.ylzinfo.empi.credit.async.AsyncUserInfoService com.ylzinfo.empi.credit.engine.UserEngineService.asyncUserInfoService; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'asyncUserInfoService': Bean with name 'asyncUserInfoService' has been injected into other beans [creditEngineService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example., dubbo version: 2.5.3, current host: 192.168.34.2" />
      <item value="relocated" />
      <item value="select" />
      <item value="nio" />
      <item value="agent" />
      <item value="encrypt" />
      <item value="lockservice" />
      <item value="INFO" />
      <item value="Mate" />
      <item value="An annotation to create utility classes. If a class is annotated with {@code @UtilityClass}, the following things happen to it:&lt;ul&gt; &lt;li&gt;It is marked final.&lt;li&gt; &lt;li&gt;If any constructors are declared in it, an error is generated. Otherwise, a private no-args constructor is generated; it throws a {@code UnsupportedOperationException}.&lt;li&gt; &lt;li&gt;All methods, inner classes, and fields in the class are marked static.&lt;li&gt; &lt;li&gt;&lt;em&gt;WARNING:&lt;em&gt; Do not use non-star static imports to import these members; javac won't be able to figure it out. Use either: &lt;code&gt;import static ThisType.;&lt;code&gt; or don't static-import.&lt;li&gt; &lt;ul&gt;" />
      <item value="correct" />
      <item value="Logger" />
      <item value="em Punish" />
      <item value="tingWith,40] - Generating unique operation named: editUsingPUT_3 21:12:07.261 [restartedMain] INFO s.d.s.w.r.o.CachingOperationNameGenerator - [startingWith,40] - Generating unique operation named: exportUsingGET_3 21:12:07.262 [restartedMain] INFO s.d.s.w.r.o.CachingOperationNameGenerator - [sta" />
      <item value="S" />
      <item value="m" />
      <item value="Invalid Property" />
      <item value="Spring Context Shutdown Hook" />
      <item value="Quartz Scheduler Ruoyi Scheduler" />
      <item value="generator" />
      <item value="Thread Pool Executor" />
      <item value="col_1_0_" />
      <item value="java: Internal error in the mapping processor: java.lang.NullPointerException at org.mapstruct.ap.internal.processor.DefaultVersionInformation.createManifestUrl(DefaultVersionInformation.java:180) at org.mapstruct.ap.internal.processor.DefaultVersionInformation.openManifest(DefaultVersionInformation.java:151) at org.mapstruct.ap.internal.processor.DefaultVersionInformation.getLibraryName(DefaultVersionInformation.java:127) at org.mapstruct.ap.internal.processor.DefaultVersionInformation.getCompiler(DefaultVersionInformation.java:120) at org.mapstruct.ap.internal.processor.DefaultVersionInformation.fromProcessingEnvironment(DefaultVersionInformation.java:98) at org.mapstruct.ap.internal.processor.DefaultModelElementProcessorContext.&lt;init&gt;(DefaultModelElementProcessorContext.java:59) at org.mapstruct.ap.MappingProcessor.processMapperElements(MappingProcessor.java:222) at org.mapstruct.ap.MappingProcessor.process(MappingProcessor.java:162) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.jetbrains.jps.javac.APIWrappers1.invoke(APIWrappers.java:248) at lombok.launch.AnnotationProcessorHiderAnnotationProcessor.process(Unknown Source) at com.sun.tools.javac.processing.JavacProcessingEnvironment.callProcessor(JavacProcessingEnvironment.java:794) at com.sun.tools.javac.processing.JavacProcessingEnvironment.discoverAndRunProcs(JavacProcessingEnvironment.java:705) at com.sun.tools.javac.processing.JavacProcessingEnvironment.access1800(JavacProcessingEnvironment.java:91) at com.sun.tools.javac.processing.JavacProcessingEnvironmentRound.run(JavacProcessingEnvironment.java:1035) at com.sun.tools.javac.processing.JavacProcessingEnvironment.doProcessing(JavacProcessingEnvironment.java:1176) at com.sun.tools.javac.main.JavaCompiler.processAnnotations(JavaCompiler.java:1170) at com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:856) at com.sun.tools.javac.main.Main.compile(Main.java:523) at com.sun.tools.javac.api.JavacTaskImpl.doCall(JavacTaskImpl.java:129) at com.sun.tools.javac.api.JavacTaskImpl.call(JavacTaskImpl.java:138) at org.jetbrains.jps.javac.JavacMain.compile(JavacMain.java:231) at org.jetbrains.jps.incremental.java.JavaBuilder.compileJava(JavaBuilder.java:501) at org.jetbrains.jps.incremental.java.JavaBuilder.compile(JavaBuilder.java:353) at org.jetbrains.jps.incremental.java.JavaBuilder.doBuild(JavaBuilder.java:277) at org.jetbrains.jps.incremental.java.JavaBuilder.build(JavaBuilder.java:231) at org.jetbrains.jps.incremental.IncProjectBuilder.runModuleLevelBuilders(IncProjectBuilder.java:1441) at org.jetbrains.jps.incremental.IncProjectBuilder.runBuildersForChunk(IncProjectBuilder.java:1100) at org.jetbrains.jps.incremental.IncProjectBuilder.buildTargetsChunk(IncProjectBuilder.java:1224) at org.jetbrains.jps.incremental.IncProjectBuilder.buildChunkIfAffected(IncProjectBuilder.java:1066) at org.jetbrains.jps.incremental.IncProjectBuilder.buildChunks(IncProjectBuilder.java:832) at org.jetbrains.jps.incremental.IncProjectBuilder.runBuild(IncProjectBuilder.java:419) at org.jetbrains.jps.incremental.IncProjectBuilder.build(IncProjectBuilder.java:183) at org.jetbrains.jps.cmdline.BuildRunner.runBuild(BuildRunner.java:132) at org.jetbrains.jps.cmdline.BuildSession.runBuild(BuildSession.java:302) at org.jetbrains.jps.cmdline.BuildSession.run(BuildSession.java:132) at org.jetbrains.jps.cmdline.BuildMainMyMessageHandler.lambdachannelRead00(BuildMain.java:219) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutorWorker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)" />
      <item value=".R" />
      <item value="pojo" />
      <item value="Business" />
      <item value="Constructs a new runtime exception with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to {@link initCause}. @param message the detail message. The detail message is saved for later retrieval by the {@link getMessage()} method." />
      <item value="A container object which may or may not contain a non-null value. If a value is present, {@code isPresent()} will return {@code true} and {@code get()} will return the value. &lt;p&gt;Additional methods that depend on the presence or absence of a contained value are provided, such as {@link orElse(java.lang.Object) orElse()} (return a default value if value not present) and {@link ifPresent(java.util.function.Consumer) ifPresent()} (execute a block of code if the value is present). &lt;p&gt;This is a &lt;a href=&quot;..langdoc-filesValueBased.html&quot;&gt;value-based&lt;a&gt; class; use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on instances of {@code Optional} may have unpredictable results and should be avoided. @since 1.8" />
      <item value="Internal" />
      <item value="Could not transfer artifact org.springframework.boot:spring-boot-dependencies:pom:2.3.7.RELEASE fromto alimaven (http:maven.aliyun.comnexuscontentgroupspublic): Transfer failed for http:maven.aliyun.comnexuscontentgroupspublicorgspringframeworkbootspring-boot-dependencies2.3.7.RELEASEspring-boot-dependencies-2.3.7.RELEASE.pom" />
      <item value="true if we are declaring a durable exchange (the exchange will survive a server restart)" />
      <item value="rue if we are declaring a durable exchange (the exchange will survive a server restart)" />
      <item value="the exchange type" />
      <item value="Actively declare a non-autodelete exchange with no extra arguments @see com.rabbitmq.client.AMQP.Exchange.Declare @see com.rabbitmq.client.AMQP.Exchange.DeclareOk @param exchange the name of the exchange @param type the exchange type @param durable true if we are declaring a durable exchange (the exchange will survive a server restart) @throws java.io.IOException if an error is encountered @return a declaration-confirm method to indicate the exchange was successfully declared" />
      <item value="Wait until all messages published since the last call have been either ack'd or nack'd by the broker. Note, when called on a non-Confirm channel, waitForConfirms throws an IllegalStateException. @return whether all the messages were ack'd (and none were nack'd) @throws java.lang.IllegalStateException" />
      <item value="true to acknowledge all messages up to and including the supplied delivery tag; false to acknowledge just the supplied delivery tag." />
      <item value="the tag from the received" />
      <item value="other properties for the message - routing headers etc" />
      <item value="the exchange to publish the message to" />
      <item value="Publishing to a non-existent exchange will result in a channel-level protocol exception, which closes the channel." />
      <item value="Publish a message." />
      <item value="Publish a message. Publishing to a non-existent exchange will result in a channel-level protocol exception, which closes the channel. Invocations of &lt;code&gt;ChannelbasicPublish&lt;code&gt; will eventually block if a &lt;a href=&quot;http:www.rabbitmq.comalarms.html&quot;&gt;resource-driven alarm&lt;a&gt; is in effect. @see com.rabbitmq.client.AMQP.Basic.Publish @see &lt;a href=&quot;http:www.rabbitmq.comalarms.html&quot;&gt;Resource-driven alarms&lt;a&gt; @param exchange the exchange to publish the message to @param routingKey the routing key @param props other properties for the message - routing headers etc @param body the message body @throws java.io.IOException if an error is encountered" />
      <item value="Invocation" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="312" />
        <entry key="ENGLISH" value="313" />
        <entry key="DANISH" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="3" />
        <entry key="ROMANIAN" value="4" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="SPANISH" value="2" />
        <entry key="ITALIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1622443815637" />
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>