<application>
  <component name="AppStorage">
    <histories>
      <item value="release" />
      <item value="acquire" />
      <item value="** * Releases a permit, returning it to the semaphore. * * &lt;p&gt;Releases a permit, increasing the number of available permits by * one. If any threads are trying to acquire a permit, then one is * selected and given the permit that was just released. That thread * is (re)enabled for thread scheduling purposes. * * &lt;p&gt;There is no requirement that a thread that releases a permit must * have acquired that permit by calling {@link #acquire}. * Correct usage of a semaphore is established by programming convention * in the application. */" />
      <item value="Barrier" />
      <item value="Semaphore" />
      <item value="usable bits of normal node hash" />
      <item value="Table initialization and resizing control. When negative, the * table is being initialized or resized: -1 for initialization, * else -(1 + the number of active resizing threads). Otherwise, * when table is null, holds the initial table size to use upon * creation, or 0 for default. After initialization, holds the * next element count value upon which to resize the table. */" />
      <item value="init Table" />
      <item value="Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead." />
      <item value="The next size value at which to resize (capacity * load factor)." />
      <item value="the table is in creation mode." />
      <item value="Adds the specified element as the tail (last element) of this list." />
      <item value="offer" />
      <item value="poll" />
      <item value="peek" />
      <item value="Returns the (non-null) Node at the specified element index." />
      <item value="@param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied." />
      <item value="Policy" />
      <item value="Rejected" />
      <item value="Synchronous Queue" />
      <item value="Count Down Latch" />
      <item value="for (int i = 0; i &lt; 6; i++) { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName()+&quot;\t离开教室&quot;); },String.valueOf(i)).start(); } System.out.println(&quot;关门&quot;);" />
      <item value="Invalid bound statement" />
      <item value="evict" />
      <item value="only If Absent" />
      <item value="starting position in the source array." />
      <item value="Internal" />
      <item value="DEFAULTCAPACITY EMPTY ELEMENTDATA" />
      <item value="Capacity" />
      <item value="calculate Capacity" />
      <item value="ensure Capacity Internal" />
      <item value="Increments modCount!" />
      <item value="Adfaith Consulting - Employee Information - Main Menu" />
      <item value="Press Enter to continue..." />
      <item value="No selection entered. Press Enter to continue…" />
      <item value="Invalid code! Press Enter to continue…" />
      <item value="Delete Records" />
      <item value="Add New Records" />
      <item value="Search for specific Record(s)" />
      <item value="Print Names and Phone Numbers (formatted)" />
      <item value="Print Names and Phone Numbers" />
      <item value="Print All Current Records (formatted)" />
      <item value="Print All Current Records" />
      <item value="The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results." />
      <item value="The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;." />
      <item value="The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the {@code iterator} and {@code listIterator} methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a {@code ConcurrentModificationException} in * response to the {@code next}, {@code remove}, {@code previous}, * {@code set} or {@code add} operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its {@code add(int, E)} and * {@code remove(int)} methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * {@code add(int, E)} or {@code remove(int)} must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus {@code ConcurrentModificationExceptions}. If an implementation * does not wish to provide fail-fast iterators, this field may be" />
      <item value="* Returns a list-iterator of the elements in this list (in proper * sequence), starting at the specified position in the list. * Obeys the general contract of {@code List.listIterator(int)}.&lt;p&gt; * * The list-iterator is &lt;i&gt;fail-fast&lt;/i&gt;: if the list is structurally * modified at any time after the Iterator is created, in any way except * through the list-iterator's own {@code remove} or {@code add} * methods, the list-iterator will throw a * {@code ConcurrentModificationException}. Thus, in the face of * concurrent modification, the iterator fails quickly and cleanly, rather * than risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * @param index index of the first element to be returned from the * list-iterator (by a call to {@code next}) * @return a ListIterator of the elements in this list (in proper * sequence), starting at the specified position in the list * @throws IndexOutOfBoundsException {@inheritDoc} * @see List#listIterator(int)" />
      <item value="DEFAULT LOAD FACTOR" />
      <item value="Iterator" />
      <item value="constant" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="249" />
        <entry key="ENGLISH" value="251" />
        <entry key="CROATIAN" value="1" />
        <entry key="ROMANIAN" value="4" />
        <entry key="SPANISH" value="2" />
        <entry key="ITALIAN" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>